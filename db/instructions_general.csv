mnemonic,name,description,flags
"ADC","ADd with Carry","ADC results are dependant on the setting of the decimal flag. In decimal mode, addition is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal). There is no way to add without carry","N, Z, C, V"
"AND","Bitwise AND","Performs bitwise AND with the accumulator; the result is stored in the accumulator","N, Z"
"ASL","Arithmetic Shift Left","Shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry","N, Z, C"
"BIT","test BITs","BIT sets the Z flag as though the value in the address tested were ANDed with the accumulator. The S and V flags are set to match bits 7 and 6 respectively in the value stored at the tested address","N, V, Z"
"BPL","Branch on PLus","Branches if the N flag is clear","none"
"BMI","Branch on MInus","Branches if the N flag is set","none"
"BVC","Branch on oVerflow Clear","Branches if the V flag is clear","none"
"BVS","Branch on oVerflow Set","Branches if the V flag is set","none"
"BCC","Branch on Carry Clear","Branches if the C flag is clear. This is often used in a less-than comparison","none"
"BCS","Branch on Carry Set","Branches if the C flag is set. This is often used in a greater-than or greater-or-equal comparison","none"
"BNE","Branch on Not Equal","Branches if the Z flag is clear (result of not equal)","none"
"BEQ","Branch on EQual","Branches if the Z flag is set(result of equal)","none"
"BRK","BReaK","Force break; causes a maskable interrupt","B"
"CMP","CoMPare accumulator","Compares the accumulator with some value. If the value in the accumulator is equal or greater than the compared value, C will be set. The Z and N flags will be set on equality or lack thereof and the sign of the accumulator (i.e. Z is set if equal; N is set if A >= $80)","N, Z, C"
"CPX","ComPare X register","Operation and flags identical to the CMP instruction (but compares X with the value)","N, Z, C"
"CPY","ComPare Y register","Operation and flags identical to the CMP instruction (but compares Y with the value)","N, Z, C"
"DEC","DECrement memory","Decrements the value at the specified location by 1. $00 rolls over to $FF. Sets N and Z based on the result of the operation","N, Z"
"EOR","bitwise Exclusive OR","Performs XOR between the accumulator and some value. Sets N and Z based on the result","N, Z"
"CLC","CLear Carry","Clears the carry bit","C"
"SEC","SEt Carry","Sets the carry bit","C"
"CLI","CLear Interrupt","Clears the interrupt disable flag (i.e. allows interrupts)","I"
"SEI","SEt Interupt","Sets the interrupt disable flag (i.e. prevents interrupts)","I"
"CLV","CLear oVerflow","Clears the V flag","V"
"CLD","CLear Decimal","Clears the decimal mode flag (disables binary-coded decimal)","D"
"SED","SEt Decimal","Sets the decimal mode flag (enables binary-coded decimal)","D"
"INC","INCrement memory","Increments the value at the specified address by 1. $FF rolls over to $00. Sets N and Z flags based on the result","N, Z"
"JMP","JuMP","Transfers program execution to the address specified by the instruction. Note that an indirect jump must never use a vector beginning on the last byte of a page, as this will cause the address to get decoded incorrectly","none"
"JSR","Jump to SubRoutine","Pushes the address of the next instruction - 1 to the stack before transfering program control to the address indicated. Normally complemented by an RTS instruction","none"
"LDA","LoaD A","Loads the A register with the specified value","N, Z"
"LDX","LoaD X","Loads the X register with the specified value","N, Z"
"LDY","LoaD Y","Loads the Y register with the specified value","N, Z"
"LSR","Logical Shift Right","Shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry","N, Z, C"
"NOP","No OPeration","Does nothing; skipped over. Typically used to reserve space for future modifications or ignore sections of memory","none"
"ORA","bitwise OR with Accumulator","Performs bitwise or with the accumulator, storing the result in the accumulator","N, Z"
"TAX","Transfer A to X","Transfers the value in A to X","N, Z"
"TXA","Transfer X to A","Tranfsers the value in X to A","N, Z"
"DEX","DEcrement X","Decrement the value in the X register by one, setting the N and Z flags based on the result","N, Z"
"INX","INcrement X","Increment the value in the X register by one, setting the N and Z flags based on the result","N, Z"
"TAY","Transfer A to Y","Transfers the value in A to Y","N, Z"
"TYA","Transfer Y to A","Transfers the value in Y to A","N, Z"
"DEY","DEcrement Y","Decrement the value in the Y register by one, setting the N and Z flags based on the result","N, Z"
"INY","INcrement Y","Increment the value in the Y register by one, setting the N and Z flags based on the result","N, Z"
"ROL","ROtate Left","Shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry","N, Z, C"
"ROR","ROtate Right","Shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry","N, Z, C"
"RTI","ReTurn from Interrupt","RTI retrieves the processor status and the program counter from the stack in that order. Note that the address retrieved is the actual address, unlike JSR and RTS where the address pushed is the return address - 1","all"
"RTS","ReTurn from Subroutine","RTS retrieves the return address - 1 from the stack and transfers control to that address + 1","none"
"SBC","SuBtract with Carry","SBC results are dependant on the setting of the decimal flag. In decimal mode, subtraction is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal). There is no way to subtract without the carry which works as an inverse borrow. i.e, to subtract you set the carry before the operation. If the carry is cleared by the operation, it indicates a borrow occurred","N, V, Z, C"
"STA","STore Accumulator","Stores the value in the A register at the specified memory location","none"
"STX","STore X register","Stores the value in the X register at the specified memory location","none"
"STY","STore Y register","Stores the value in the Y register at the specified memory location","none"
"TXS","Transfer X to Stack pointer","Transfers the value in the X register to the stack pointer. Note the stack is always between $0100 and $01FF, so this affects only the low byte of the stack address","none"
"TSX","Transfer Stack pointer to X","Transfers the low byte of the stack pointer to the X register","none"
"PHA","PusH Accumulator","Pushes the value in A onto the stack and then decrements the value in the stack pointer by 1. Note that on the 6502, the stack grows downwards","none"
"PLA","PuLl Accumulator","Increments the stack pointer by 1 and transfers the value at that address to the accumulator. Note that on the 6502, the stack grows downwards","none"
"PHP","PusH Processor status","Pushes the processor status onto the stack and decrements the stack pointer","none"
"PLP","PuLl Processor status","Increments the stack pointer by one and pulls the value into the processor status register","none"
